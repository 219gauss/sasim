/*
优化：拿起手柄时，屏幕休眠唤醒，并启动拨号APP
	  放下手柄时，退出拨号APP(如果还没退出的话)

出现的问题：在每次机器休眠后(断开usb),拿起手柄，屏幕休眠唤醒，并启动拨号APP，
			但是放下手柄时，很大概率会出现 拨号APP没有退出的情况，要重新拿起放下才退出

应用层 									监听广播  ----> 退出APP
											|
framework 				监听按键  ---->  发广播 	
							|
驱动	产生中断  ---->  上报键值
		  |
手柄   	放下

*/

应用层：放下手柄时，接收广播，APP关闭，

-->打log发现，放下手柄(出问题时)，广播的log没打出来，怀疑framework层没发广播

framework层：放下手柄时，发送广播通知APP关闭，

-->打log发现，放下手柄(出问题时)，按键监听的log没打出来，按键相关操作没执行，怀疑没上报键值

getevent：监听按键上报

-->监听是发现，放下手柄(出问题时)，手柄按键有时没有上报键值，怀疑是不是按键驱动里没有上报键值

解决思路一：放下手柄(出问题时)，再次抬起放下，APP正常关闭，那在手柄抬起放下的时候驱动去上报两次键值，应该至少能监听到一次。

        int stats = getHookStatus() ? 1 : 0;
		if(hookStatus != stats) {
				hookStatus = stats;
		} else {
			break;
		}
		/*
							上报
			产生中断     ---------->	监听
				|						 |
				| 1，修改				 | 2，读取
				\						/
				  >		设备文件  	  <

			当产生中断到执行相应操作的这段时间内，再次产生中断不至于导致按键"跑飞"
		*/
后面发现，放下手柄，APP还是没退，通过getevent发现，每次手柄抬起唤醒时，有时会连续上报两次，每次这种情况出现，手柄放下APP一定不退出，
怀疑可能是按键没有消抖造成的。

修改代码，在工作队列中添加

	int val[3];
	for(i = 0; i<3; i++){
		val[i] = gpio_get_value(data->hook_gpio);
		msleep(5);
	}
	if(val[0] != val[1] || val[0] != val[2]) {
		goto out;
	}
经过测试，发现加了消抖代码后，没有出现上面的问题

进一步分析发现，这种写法也不会出现问题，分析可能是按键中断后执行工作队列函数时，不能马上读取gpio口的值，至少先延时几个毫秒
	
	int val;
	msleep(5);
	val = gpio_get_value(data->hook_gpio);

经后面测试，采用消抖的方式，因为直接延时在狂按按键后，有时会出错

	
